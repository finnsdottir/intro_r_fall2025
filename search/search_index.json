{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction  to R (and RStudio)","text":"<p>Welcome to this workshop on R and R studio! In this session, participants will learn the basics of coding in R, and will become familiar with using RStudio. We will cover creating objects, importing and working with data, using the basic libraries, and performing simple operations.  </p> <p>This session is suitable for beginners with no prior knowledge of R. There are no prerequisite coding skills. While the examples and data used will be aimed at the Humanities and Social Sciences community, the session is open to anyone and everyone interested in learning about R.</p>"},{"location":"#learning-outcomes","title":"Learning outcomes","text":"<ol> <li>Learn to use RStudio</li> <li>Become familiar with the basic syntax and concepts of R</li> <li>Be able to create projects and organized working directories</li> <li>Become familiar with R packages, including \u2018tidyverse\u2019 and \u2018ggplot2\u2019</li> <li>Be able to conduct basic data analysis and visualisations</li> </ol>"},{"location":"#before-we-start","title":"Before we start","text":"<p>To start, you\u2019ll need to download both R and RStudio. Click here to download R, and here to download RStudio. </p> <p>For the project portion of the workshop, we\u2019ll be using the cleaned up messy movies data. If you have yours from the OpenRefine workshop, feel free to use that! If not, you can download the unmessy_movies.csv data here. </p> <p>I'd encourage you to follow along with the workshop in R, but if you get lost or want to check something, you can download my script.</p> <p>Instructor: Maria Sigridur Finnsdottir, PhD</p> <p>This workshop was developed by drawing on the UBC Library course Intro to R and RStudio (beginner) and the Data Carpentries course R for Social Scientists.</p> <p>This work is licensed under a  Creative Commons Non-Commerical Attribution 4.0 International License.</p>"},{"location":"analysing/","title":"Data Wrangling with dplyr","text":"<p><code>dplyr</code> is another important package in R that makes it easy to extract and summarize insights from tabular data. Luckily, <code>dplyr</code> is included in <code>tidyverse</code> and was loaded into R's memory when we called <code>library(tidyverse)</code>.</p> <p>In this section, we're going to cover just the most common <code>dplyr</code> functions:</p> <ul> <li><code>select()</code>: subset columns</li> <li><code>filter()</code>: subset rows on conditions</li> <li><code>mutate()</code>: create new columns by using information from other columns</li> <li><code>group_by()</code> and <code>summarize()</code>: create summary statistics on grouped data</li> <li><code>arrange()</code>: sort results</li> <li><code>count()</code>: count discrete values</li> </ul>"},{"location":"analysing/#selecting-filtering","title":"Selecting &amp; filtering","text":"<p>Selecting and filtering are both techniques to focus in on some chosen data in a data frame. <code>select()</code> is used to select specific columns of a data frame. When we call <code>select()</code>, the first argument in the parentheses will be the data frame, followed by the columns to keep, separated by commas.  <pre><code>select(unmessy_movies, movie_title, year, runtime, primary_genre)\n</code></pre> Since these columns are adjacent to one another in our data frame, we can get the same result by using <code>:</code>. <pre><code>select(unmessy_movies, movie_title:primary_genre)\n</code></pre></p> <p>Filtering, on the other hand, is used to select out rows based on conditions. To use <code>filter()</code>, you put the data frame as the first argument inside the parentheses, and the conditions as the second. For example, we can filter our data frame by Music genre like so: <pre><code>filter(unmessy_movies, primary_genre==\"Music\")\n</code></pre> We can add further conditions to our filter, seperated by commas. For example, we can filter our data down to action movies under 60 minutes long by running the following code: <pre><code>filter(unmessy_movies, primary_genre==\"Action\",\n                        runtime &lt; 60)\n</code></pre> Practice. Using the filter function, find how many Animation movies were released before 1990. </p> Solution <pre><code># You should filter the data by primary genre and year, like so:\nfilter(unmessy_movies, primary_genre=='Animation', year&lt;1990)\n\n#Your output should include 21 movies. \n</code></pre>"},{"location":"analysing/#pipes","title":"Pipes","text":"<p>Pipes are a way to do more complicated operations in R, such as selecting and filtering at the same time. Pipes let you take the output of one function and send it directly to the next, which is useful when you need to do many things to the same dataset. </p> <p>There are two Pipes in R: the magrittr pipe (installed automatically with <code>dplyr</code>) and the native pipe. In this workshop, we will be using the margrittr pipe. Both the pipes are, by and large, function similarly with a few differences (For more information, check the tidyverse site). The choice of which pipe to be used can be changed in the Global settings in R studio.</p> <p>Pipes are represented by <code>%&gt;%</code> in R. Rather than type it out every time, you can use the following keyboard shortcut: Ctrl+Shift+M (on PC) or Cmd+Shift+M (on mac). </p> <p>Let's start by using pipes to view information about the director for every sci-fi movie. To do this, we want to filter by genre, and then select for director and director ID. <pre><code>unmessy_movies %&gt;%\n    filter(primary_genre==\"Sci-Fi\") %&gt;%\n    select(movie_title, director_name, director_id)\n</code></pre> Running that command should print the following to your console: </p> <p>In the above code, we use the pipe to send the movies dataset first through <code>filter()</code> to keep rows where the primary genre is \"Sci-Fi\" then through <code>select()</code> to keep only the columns \"movie_title\", \"director_name\", and \"director_id\". Since <code>%&gt;%</code> takes the object on its left and passes it as the first argument to the function on its right, we don\u2019t need to explicitly include the dataframe as an argument to the <code>filter()</code> and <code>select()</code> functions any more.</p> <p>The dplyr functions by themselves are somewhat simple, but by combining them into linear workflows with the pipe, we can accomplish more complex data wrangling operations.</p> <p>If we want to create a new object with this smaller version of the data, we can assign it a new name: <pre><code>scifi_movies &lt;- unmessy_movies %&gt;%\n    filter(primary_genre==\"Sci-Fi\") %&gt;%\n    select(movie_title, director_name, director_id)\n</code></pre> Practice. Using pipes, subset the unmessy movies data to include only Action movies and retain only the columns for movie title, year, and average rating. Create a new object with this data, and assign it the name \"action_movies.\"</p> Solution <pre><code>#Your code should look like this: \n\naction_movies &lt;- unmessy_movies %&gt;%\n    filter(primary_genre==\"Action\") %&gt;%\n    select(movie_title, year, ave_rating)\n\n#this will produce a data frame object with 3 variables and 467 observations. \n</code></pre>"},{"location":"analysing/#mutate","title":"Mutate","text":"<p>Frequently you\u2019ll want to create new columns based on the values in existing columns, for example to do unit conversions, or to find the ratio of values in two columns. For this we\u2019ll use mutate().</p> <p>For example, you might be interested in the number of writers on each movie. For this, we will need to create a new column (variable) countaining a count of the number of writer ids in each row of the <code>writer_id</code> column. We will need to start by formatting our <code>writer_id</code> column so that each row is a list. Then, we can pipe it into a mutation creating a variable counting the number of items. For this, we will use the function <code>lengths()</code>.</p> <pre><code>unmessy_movies %&gt;%\n  mutate(writers_id = strsplit(writers_id,\",\")) %&gt;%\n  mutate(num_writers = lengths(writers_id))\n</code></pre> <p>Practice. How would we change the code above to save our new <code>num_writers</code> variable?</p> Solution <p>To add this new variable to our data frame, we need to assign the data to another object. It's good practice to create a new data frame in cases like this, leaving the original data intact. So, you could do something like this: <pre><code>unmessy_movies2 &lt;- unmessy_movies %&gt;%\n    mutate(writers_id = strsplit(writers_id,\",\")) %&gt;%\n    mutate(num_writers = lengths(writers_id))\n</code></pre></p>"},{"location":"analysing/#split-apply-combine","title":"Split-apply-combine","text":"<p>Many data analysis tasks can be approached using the split-apply-combine paradigm: split the data into groups, apply some analysis to each group, and then combine the results. <code>dplyr</code> makes this very easy through the use of the <code>group_by()</code> function.</p>"},{"location":"analysing/#the-summarize-function","title":"The summarize() function","text":"<p><code>group_by()</code> is often used together with summarize(), which collapses each group into a single-row summary of that group. </p> <p><code>group_by()</code> takes as arguments the column names that contain the categorical variables for which you want to calculate the summary statistics. Always end your <code>group_by()</code> operations with the <code>ungroup()</code> function. So, if we wanted to calculate the average rating per primary genre, we could do the following: <pre><code>unmessy_movies %&gt;%\n    group_by(primary_genre) %&gt;%\n    summarize(mean_rating = mean(ave_rating))%&gt;%\n    ungroup()\n</code></pre> Running this code should print the following output to your console: </p> <p>We also have the option of specifying the sort order of our data. To do this, we need to add a <code>arrange()</code> function to the end of our pipeline. So, if we wanted to sort the primary genres by their average rating, we could do this:  <pre><code>unmessy_movies %&gt;%\n  group_by(primary_genre) %&gt;%\n  summarize(mean_rating = mean(ave_rating))%&gt;%\n  arrange(mean_rating)%&gt;%\n  ungroup()\n</code></pre> We can further customize our sorting to be from highest to lowest by adding the <code>desc()</code> function. The <code>desc()</code> function is nested inside the <code>arrange()</code> function like so <code>arrange(desc(x))</code>. </p> <p>Practice. Use the <code>arrange()</code> and <code>desc()</code> functions to modify the above code so that our output is arranged from highest mean average rating to lowest. Assign the output to a new object called \"genre_ratings.\"</p> Solution <pre><code>genre_ratings &lt;- unmessy_movies %&gt;%\ngroup_by(primary_genre) %&gt;%\nsummarize(mean_rating = mean(ave_rating))%&gt;%\narrange(desc(mean_rating))%&gt;%\nungroup()\n</code></pre>"},{"location":"analysing/#counting","title":"Counting","text":"<p>The <code>count()</code> function in <code>dplyr</code> lets us count (intuitive, I know) observations. Importantly, we can include arguments that allow us to count observations based on different factors or combinations or factors. </p> <p>To use the <code>count()</code> function to count the values in a column within a data frame, we need to pipe it from the data frame object. </p> <p>For example, let's use the <code>count()</code> function to count the number of movies released in each year.  <pre><code>unmessy_movies %&gt;% \n  count(year)\n</code></pre></p> <p>Now, let's add a <code>sort</code> argument. This will show us which years had the most movies released.  <pre><code>unmessy_movies %&gt;% \n  count(year, sort=TRUE)\n</code></pre> It looks like 2009-11 were the most productive years in our data set! </p>"},{"location":"basics/","title":"Basic Syntax &amp; Concepts","text":"<p>Before we start working with our unmessy movies dataset,let's go over some of the basic concepts and syntax in R. One important thing to note is that all data structures in R are referred to as 'objects.' This means that data frames, vectors, and variables are all different kinds of objects in R. </p>"},{"location":"basics/#operators","title":"Operators","text":"<p>Operators are special symbols or keywords used to perform operations on one or more values. Common operators include:</p> <ul> <li>Assignment operators. We can use the operators <code>&lt;-</code> and <code>=</code> to assign a value to a variable/object. When naming an object in R, avoid using the names of fundamental objects (like 'mean), periods, or numbers at the beginning. Try creating variables for the day and month and assigning them values by running the following in the Source Editor:  <pre><code>day &lt;- 3\nmonth = 10\n</code></pre></li> </ul> <p>Note</p> <p>RStudio allows for several quick keyboard shortcuts. One is to press Alt+- (on PC) or Option+- (on mac) to write <code>&lt;-</code></p> <ul> <li>Arithmetic operators. The operators <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> are used for basic mathematical calculations, namely addition, subtraction, multiplication, and division. Try running the following in your Source Editor and watching what appears in the console: <pre><code>4+2\n4/2\n</code></pre></li> </ul> Output <pre><code>&gt; 4+2\n[1] 6\n&gt; 4/2\n[1] 2\n</code></pre> <ul> <li>Comparison operators. The operators <code>&lt;</code>, <code>&gt;</code>, and <code>==</code> return a logical value when used to compare two things. Try running the following: <pre><code>4!=3\n4&lt;3\n</code></pre></li> </ul> Output <pre><code>&gt; 4!=3\n[1] TRUE\n&gt; 4&lt;3\n[1] FALSE\n</code></pre> <ul> <li>Logical operators. The operators <code>&amp;</code> (and), <code>|</code> (or), and <code>!</code> (not) are used to perform logical operators. These are a bit more complicated to use, but here is a simple example: <pre><code>#the single &amp; operator represents an element-wise logical AND. It will return TRUE if both corresponding elements are true. Run the following:\nc(TRUE,TRUE,FALSE) &amp; c(TRUE,FALSE,FALSE)\n\n#Running the code above should return the following output:\n[1]  TRUE FALSE FALSE\n</code></pre></li> <li>Other miscellaneous operators:<ul> <li>The hash sign <code>#</code> indicates a comment in the code</li> <li>The colon sign <code>:</code> creates a sequence of numbers </li> <li>The square brackets <code>[]</code> indexed an object, such as a vector</li> <li>The dollar sign <code>$</code> accesses a variable from a dataframe</li> <li>The percent sign <code>%</code> is used for some special operators to string operations together</li> <li>The double colon <code>::</code> accesses functions or variables from a specific package</li> </ul> </li> </ul>"},{"location":"basics/#data-types","title":"Data types","text":"<p>The most common data types in R are:</p> <ol> <li>Numeric data (numbers with decimal points, either integers or floats)</li> <li>Character data (text strings)</li> <li>Factor data (categorial data with a fixed set of values or levels)</li> <li>Logical data (boolean values or logical values)</li> </ol> <p>Data types are important because they determine how data is stored, processed, and analyzed. Choosing the appropriate data type can help you optimize your memory usage, perform the necessary data manipulations, conduct the appropriate statistical analyses, and create effective visualizations of your data.</p>"},{"location":"basics/#data-frames","title":"Data frames","text":"<p>Data frames are a very common type of data structure used in R. A data frame is a two-dimensional tabular structure representing a grid of data, where each row represents an observation and each column represents a variable. </p>"},{"location":"basics/#vectors","title":"Vectors","text":"<p>Vectors are another important type of data structure in R. A vector is a basic, one-dimensional data structure that represents a sequence of values of the same data type, whether numbers or letters. </p> <p>Creating vectors is straightforward: you just use the assignment operator and the c() function, which combines values. Try running the following code to make some vectors describing the Hollywood Chris's: <pre><code>chris_vector &lt;- c('pratt','hemsworth')\nchris_age_vector &lt;- c(44,46,42,45)\n</code></pre> Now that you've created these two vectors, you should see them in your environment in the top right pane of the RStudio console.</p> <p>Note</p> <p>Be sure to include quotation marks around the text data you're combining into a vector. If you do not have them, R will assume that you are referring to objects, not data values.</p> <p>You can call functions on vectors. For example, you can inspect the length, structure, and type of vectors. Run these three functions. Your output will appear in the console - did you get what you expected to see? <pre><code>length(chris_age_vector)\nstr(chris_age_vector)\ntypeof(chris_vector)\n</code></pre></p> Output <pre><code>&gt; length(chris_age_vector)\n[1] 4\n&gt; str(chris_age_vector)\n num [1:4] 44 46 42 45\n&gt; typeof(chris_vector)\n[1] \"character\"\n</code></pre> <p>It is also fairly straightforward to add elements to the beggining or end of your vector. Run the following code in your source editor or console: <pre><code>chris_vector &lt;-c(chris_vector, \"pine\")\nchris_vector &lt;-c(\"evans\",chris_vector)\n</code></pre> Once you've done this, you should see the values of chris_vector change in the environment pane.</p> <p>Importantly, if you try to put data of different types into one vector, R will coerce them automatically to all be the same type.</p> <p>Let's try creating a vector including the last name and age for two of the Hollywood Chris's. Basically, we are trying to make a vector with two strings and two integers. <pre><code>name_age_vector &lt;- c(\"evans\", 44, \"pratt\", 46)\n</code></pre> What happens to the data in our vector? Call <code>str(name_age_vector)</code>. How has R changed it? </p> Solution <p>R will have coerced the vector into a character vector. This means that all four values, the ages included, will be treated as text. </p> <p>When different data types are combined within a single atomic vector, R applies a coercion hierarchy to determine the resulting data type of the entire vector. Data are coerced from simplest to richest, followng the order of Logical -&gt; Integer -&gt; Numeric -&gt; Complex -&gt; Character. </p> <p>For example: If a vector contains both logical and integer values, all logical values will be coerced to integer (e.g., TRUE becomes 1, FALSE becomes 0). Or, if a vector contains numeric and character values, all numeric values will be coerced to character (as happened in our example).</p>"},{"location":"basics/#functions","title":"Functions","text":"<p>A function is a 'canned script' that automates a block of code that performs a specifc task and can be easily called and executed by the user. Functions are an essential component of programming in R. </p> <p>When R is installed, it comes with the default package <code>base</code> which contains a number of useful built-in functions. These include:</p> <ul> <li><code>mean()</code> calculates the mean of a vector of numbers</li> <li><code>sd()</code> calculates the standard deviation of a vector of numbers</li> <li><code>str()</code> displays the structure of an R object</li> <li><code>table()</code> creates a frequency table of a vector or factor</li> <li><code>plot()</code> creates a basic plot of data</li> </ul> <p>Try calculating the average age of the Hollywood Chris's using some of R's built-in functions. What function will you use? What output do you get? </p> Output <pre><code>&gt; mean(chris_age_vector)\n[1] 44.25\n</code></pre> <p>You can also define your own functions in R using the function <code>function</code>, like so:  <pre><code>my_function &lt;- function (arguments){\n    R code to be excuted\n    }\n</code></pre></p>"},{"location":"basics/#packages","title":"Packages","text":"<p>Different packages in R will come with their own built-in functions. Packages are collections of data, functions, and documentation. Packages are how we expand R beyond the base package. </p> <p>R packages are developed by the user community, and are all available for free. The Packages tab in RStudio lists all packages already installed in your R instance. </p> All already installed packages are listed under the Packages tab. <p>For a full list of all published packages, you can check out the R website.</p> <p>Packages only need to be installed once. Once they're installed, though, you do need to call them before you can use them and their built-in functions. Let's practice installing and calling packages with <code>tidyverse</code>, a very common R package for simple data work.  <pre><code>#installing a package\ninstall.packages('tidyverse')\n\n#calling a package\nlibrary(tidyverse)\n</code></pre> Now you should see <code>tidyverse</code> appear in the Packages tab. </p> <p>Alternatively, you can install a package by clicking the Install button on the top left of the Packages pane. Similarly, you can load a package by checking the box beside the installed package. In both cases, you will see the work that R is doing to install and load the package in the Console. </p>"},{"location":"basics/#missing-data","title":"Missing data","text":"<p>As a progamming language made for analysing datasets, R includes ways of dealing with missing data. Missing data is represented as <code>NA</code> in R. When doing operations on numbers in R, most functions will return <code>NA</code> if there are missing values in your data. </p> <p>One way to sidestep this problem is to include the argument <code>na.rm=TRUE</code> in your operation. This tells R to calculate the result while ignoring missing values. </p> <p>To test this out, let's start by adding a missing value to our <code>chris_age_vector</code> and trying to calculate the mean.  <pre><code>chris_age_vector &lt;- c(NA, chris_age_vector)\nmean(chris_age_vector)\n</code></pre> What happens when we try to calculate the mean? How do we fix our function? </p> Solution <pre><code>#if we want to calculate the mean of our chris age vector, we need to add an argument to remove the missing value from our calculation.\n\nmean(chris_age_vector, na.rm=TRUE)\n\n#When you run this new function, you should get an output of 44.25. \n</code></pre> <p>You can also check whether your data has any missing values using <code>is.na()</code>. This command returns a logical value of either TRUE or FALSE depending on whether there are missing values in your object or not. </p>"},{"location":"basics/#saving-your-work","title":"Saving your work","text":"<p>Saving your work is a crucial piece of the workflow in R. Throughout this workshop, we will be saving our work, including the data frames, plots, and script we create. </p> <p>You can save your script simply by clicking the save button (the one that looks like a floppy disk) in the tool bar of the Source Editor. From there, it will prompt you to choose a name and location to save your file. </p> <p>Plots can be saved in two ways. One option is to click the Export button in the tool bar of the Plot tab in the bottom right hand pane of RStudio. Alternatively, you can run code in your script to save your plots. The specific code will vary across packages; to save your plots in <code>ggplot2</code>, which we will cover towards the end of this session, you can run the following code:  <pre><code>ggsave(\"your_plot_name.png\", plot = your_plot)\n</code></pre></p> <p>Finally, to save data frames, you'll need to write them into the folder where you'd like them saved. We'll practice this later, but the basic code for saving a dataframe is as follows: <pre><code>write.csv(data_frame_name, \"./path\")\n</code></pre></p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>We're now going to put some of these functions and operations into practice, and use them to explore our dataset of movies. </p>"},{"location":"getting_started/#creating-a-project","title":"Creating a project","text":"<p>Start by creating a new project. To do this, navigate to File and select New Project. From there, you will be given the option to create a project from a new or existing directory. Select New Directory and then New Project. </p> <p>You will then be able to give your new project a directory name; I'm going to name mine unmessy_movies. You also have the option of creating the project as a subdirectory of another directory. I am going to create my project as a subdirectory of <code>~/Documents/R</code> (a folder I created to store my R work), but you can put yours where you like, or even leave it blank.</p> You can determine the name and location of your new project"},{"location":"getting_started/#setting-a-working-directory","title":"Setting a working directory","text":"<p>It is always a good idea to set up an organized working directory. The working directory refers to the location on your computer where R will be reading and writing files. </p> <p>We're going to set up a fairly simple organization scheme, with separate file folders for:</p> <ul> <li><code>data/</code> to store your raw data and intermediate datasets. For the sake of transparency and provenance, you should always keep a copy of your raw data accessible and do as much of your data cleanup and preprocessing programmatically (i.e., with scripts, rather than manually) as possible,</li> <li><code>data_output/</code> to store modified data separtely from the original datasets,</li> <li><code>fig_output/</code> to store any graphics we generate, and</li> <li><code>scripts/</code> to store our R scripts.</li> </ul> <p>To create these four folders, run the following code:</p> <pre><code>dir.create('data')\ndir.create('data_output')\ndir.create('fig_output')\ndir.create('scripts')\n</code></pre> <p>Note</p> <p>You can check your working directory by running the command <code>getwd()</code>. If you are not where you'd like to be working, you can set your working directory by running the command <code>setwd('my/path')</code> where 'my/path' is the filepath to your desired directory. Try running <code>getwd()</code>. Is the output what you expected?</p>"},{"location":"getting_started/#importing-data","title":"Importing data","text":"<p>Now that we have our working directory set up, we can import our unmessy_movies.csv data. </p> <p>There are two ways to import data. The simplest way is to navigate to the Import Dataset dropdown menu in the toolbar of the Environment tab. From there, select the appropriate source (in this case, From Text(base)...). That will open a pop up window where you can navigate to, and select, your data. </p> <p>Alternatively, you can run code to import the data. Run the code below, after updating the filepath with one that locates the data on your computer. <pre><code>unmessy_movies &lt;- read.csv(\"~/Downloads/unmessy_movies.csv\")\n</code></pre></p> <p>Important!</p> <p>I use a macbook, so the filepaths here are formatted for mac. If you are using Windows, you will need to update the filepaths as appropriate. In Windows, filepaths generally start with \"C:/\" </p> <p>Now that our data is loaded in R, we will want to save it. To do so, run the following line of code:  <pre><code>write.csv(unmessy_movies,\"./data/original_unmessy_movies.csv\")\n</code></pre> If you want to get a closer look at your data, you can either double click it in the environment pain, or run the command <code>view(unmessy_movies)</code>. There are also several functions you can use to inspect your data; we'll cover those next. </p>"},{"location":"inspecting/","title":"Inspecting, Subsetting, and Examining Data","text":"<p>Now that our data is uploaded into R, we can start to examine it. A viewer tab will likely have opened when you imported your data (in the Source Editor), but if not, you can run the command <code>View(unmessy_movies)</code> to see it. Remember, R is case sensitive, so be sure to write View not view. </p> <p>Our dataset includes twelve variables. Try running <code>names(unmessy_movies)</code> to view a list of the variable names. You should see a list containing the following:</p> <ul> <li>movie_id (provides a unique identifier for each movie in the dataset)</li> <li>movie_title (the title of the movie, in English)</li> <li>year (the year of release for the movie)</li> <li>runtime (the runtime of the movie)</li> <li>genres (the genres under which the movie is listed in IMBD)</li> <li>primary_genre (the primary genre for the movie)</li> <li>ave_rating (the average rating of the movie)</li> <li>num_votes (the number of votes used to calculate the rating)</li> <li>director_id (a unique identifier for the movie's director)</li> <li>director_name (the full name of the movie's director)</li> <li>writers_id (a list of unique identifiers representing each of the writers of the movie)</li> <li>writers_name (a list of the names of the writers of the movie)</li> </ul>"},{"location":"inspecting/#inspecting-data","title":"Inspecting data","text":"<p><code>names()</code> is only one of a number of functions we can call to inspect our data frame. Let's try a few more:  <pre><code>dim(unmessy_movies) #will return a vector with the dimensions of the table (number of rows, and number of columns)\n\nstr(unmessy_movies) #will return information on the structure of the object (a data frame in this case) and on the class, length, and content of each column\n\nhead(unmessy_movies) #will show the first six rows of the data frame\ntail(unmessy_movies) #will show the last six rows of the data frame\n</code></pre></p>"},{"location":"inspecting/#subsetting-data-frames","title":"Subsetting data frames","text":"<p>R allows us to extract specific information from data frames, if we are only interested in some subset of the data. To access this specific data, you need to specify the indices (the location) of the data. This is done by  listing the row number of the data point  followed by the column number inside square brackets. Try running the following code:  <pre><code>unmessy_movies[2,2]\n</code></pre> Here, we have extracted the data found in the second row and second column of the unmessy_movies data frame. You should get the following output: </p> <p>Output</p> <pre><code>[1] \"The Abyss\"\n</code></pre> <p>There are a number of ways to customize your subset. For one, you can subset out a range of rows and/or columns by using <code>:</code>, which creates a numeric vector of ordered integers. You can also subset all rows or columns by leaving the row or column position in the square brackets blank. Finally, by using the <code>-</code> sign, you can exclude a row or column. Let's give it a try! Run the following code and note your output. <pre><code>unmessy_movies[2,1:5]\nunmessy_movies[ ,2]\nunmessy_movies[2,-1]\n</code></pre></p> <p>Output</p> <ol> <li>You should get the data from columns one thorugh five for row two (the movie_id, movie_title, year, runtime, and genres)</li> <li>This will give you the values from column 2 for every row in the data frame</li> <li>This will give you the data from row two with the exception of column one (the movie_id)</li> </ol> <p>Practice. It might also be useful to turn our subsets into their own objects. To do this, we need to assign the subset to another object. Let's practice this by creating a subset of just the first 100 rows of the dataframe. Name your new data frame \"movies_first100.\"</p> Solution <pre><code>movies_first100 &lt;- unmessy_movies[1:100, ]\n</code></pre> <p>Before we move on, let's practice saving data by saving our data frame \"movies_first100\" to the data outputs folder. You may need to modify the file path in the function if you're using a PC. <pre><code>write.csv(movies_first100, \"./data_output/movies_first100.csv\")\n</code></pre></p>"},{"location":"inspecting/#using-factors","title":"Using factors","text":"<p>Factors are a type of data structure designed to deal with categorical data. Factors are particularly useful when creating plots or doing simple statistical analysis on categorical/textual data. </p> <p>Factors store categorical data as integers associated with labels. These labels can be ordered (ordinal) or unordered (nominal). They are ordinal when the order of the integers matters (like in a scale), and nominal when it does not (like in a list of colours).</p> <p>While factors look (and often behave) like character vectors, they are actually treated as integer vectors by R. So you need to be very careful when treating them as strings.</p> <p>Once created, factors can only contain a pre-defined set of values, known as levels. By default, R always sorts levels in alphabetical order.</p> <p>We can use factors to better understand the distribution of genres in our data frame. First, let's work through the codeblock below to identify the different genres.  <pre><code>#Start by creating a factor from the primary_genre variable/column\ngenres &lt;- factor(unmessy_movies$primary_genre)\n\n#Next, use the levels() function to print a list of genres. You should see 22 different genres. \nlevels(genres)\n</code></pre> Now, let's say we'd like to combine the Music and Musical genres (given that they're both music-y). To do that, we would run the following:  <pre><code>genres &lt;- fct_recode(genres, Music=\"Musical\")\n</code></pre> Now, run the <code>levels()</code> command again. What change do you see? </p> <p>Finally, let's plot out the distribution of our 21 genres. To do this, run the <code>plot(genres)</code> command. You should see a plot appear in the bottom right pane.  </p> Simple plot of the twenty one genres in our data frame. <p>Since we're working in <code>base</code> R, we can save the plot by navigating to the Export button on the Plots pane. From there, save your plot as a jpeg in the <code>figs_output/</code> folder. There are other ways to save graphs which we will cover later. </p>"},{"location":"land_acknowledgement/","title":"Land Acknowledgement","text":"<p>Before we start the lesson, let's take a moment to think about the land on which we are learning and teaching. </p> <p>I'm teaching this lesson from Edmonton, Alberta. The city of Edmonton is located on Treaty Six Territory. </p> <p>This territory has been a home, a trading post, a travelling route, and more for generations of Indigenous Peoples. In particular, the n\u00eahiyaw (Nay-hee-yow) / Cree, Dene (Deh-neyh), Anishinaabe (Ah-nish-in-ah-bay) / Saulteaux (So-toe), Nakota Isga (Na-koh-tah ee-ska) / Nakota Sioux (Na-koh-tah sue), and Niitsitapi (Nit-si-tahp-ee) / Blackfoot peoples have lived, learned, and work in this place for centuries. This land is also a homeland for the M\u00e9tis, and the home of one of the largest communities of Inuit south of the 60th parallel. </p> <p>In this map from native-land.ca you can see a pin representing Edmonton.</p> Edmonton is located within Treaty 6 Territory <p>Land acknowledgements are just one small piece of the work of reconciliation and must be undertaken in conjunction with other works. Acknowledging the land provides a foundation for recognizing Indigenous sovereignty and self-determination, for respecting Indigenous culture and language, and for committing to reconciliation and allyship. </p>"},{"location":"rstudio/","title":"R and RStudio","text":"<p> What is R?  R is a specialized programming language for statistics. While R does have a fairly steep learning curve (compared to SPSS or STATA), it is free, open-source, extendable, customizable, and reproducible. </p> <p>RStudio, on the other hand, is an integrated development environment (IDE) for R. Basically, it\u2019s an easier and more intuitive way to work with R. When you use RStudio, you work with your data and write your scripts in the IDE, and then it executes your commands in R in the background. This is why you need both R and RStudio to use RStudio. </p>"},{"location":"rstudio/#using-rstudio","title":"Using RStudio","text":"<p>When you open RStudio, you\u2019ll see the interface which has a toolbar (with buttons including File, Edit, Code, etc.) and four panes. </p> RStudio's interface. <p>On the top left is the Source Editor. This is where your script will be. You should write your code and execute it from a script file in the source editor, especially if you want to save it for future use or for sharing. </p> <p>Note</p> <p>If this is your first time opening RStudio, the source editor might not show up. If that happens, just click on File in the toolbar, navigate to New File, and then click on R Script. A script file titled \"Untitled 1\" should appear in your source editor. </p> <p>On the bottom left is the Console. The console shows the work that R is doing. You can also write commands in the console, but they will not be saved when you close the program. </p> <p>The top right pane contains the tabs Environment, History, Connections, and Tutorial. The first two are more useful: Environment lists all the objects you have in your workspace (including dataframes and variables), while History shows the commands that have been entered. </p> <p>Finally, the bottom right pane includes the tabs Files, Plots, Packages, Help, Viewer, and Presentation. Files, as the name implies, allows you to see the files on your computer and to navigate your file system. Plots allows you to view any graphs or plots you create in RStudio. </p> <p>Next, the Packages tab opens a list of all installed packages and links to their documentation. The Help tab, meanwhile, provides links to all of R's help documentation. </p> <p>For more information on all these tabs, check out the RStudio IDE cheat sheet.</p> <p>Note</p> <p>It is a good idea to format RStudio so that it doesn\u2019t automatically save your workspace. Automatically saving your workspace takes up a lot of memory, and could make troubleshooting and sharing code harder.    To do this, go first to Tools and then select Global Options. From there, select General and select Never for Save workshop to .RData on exit under the Workspace heading.</p> <p>There are two ways to run code in R. </p> <ol> <li>Press the Run button on the top right of the Source Editor pane. This will run the line where your cursor is. To run more than one line of code, highlight the lines and then press one. </li> <li>Use the keyboard shortcut Ctrl+Enter (on windows) or Cmd+Enter (on macbook). This will run the line where your cursor is. To run more than one line of code, highlight the lines and then use the keyboard shortcut. </li> </ol>"},{"location":"visualizing/","title":"Data Visualisation","text":"<p>There are many ways to create visualizations in R, including and beyond the plots in <code>base</code> R. While <code>base</code> R is great for simple and quick visualizations (like the distribution of genres plot we created earlier), there are other packages that are better for creating complex and customizable ones - including <code>ggplot2</code>. <code>ggplot2</code>, like <code>dplyr</code>, is included in the <code>tidyverse</code> package. </p> <p><code>ggplot2</code> makes it simple to create complex plots from data stored in a data frame. It provides a programmatic interface for specifying what variables to plot, how they are displayed, and general visual properties. Therefore, we only need minimal changes if the underlying data change or if we decide to change from a bar plot to a scatterplot. This helps in creating publication quality plots with minimal amounts of adjustments and tweaking.</p>"},{"location":"visualizing/#building-plots","title":"Building plots","text":"<p>ggplot graphics are built step by step by adding new elements. Each chart built with <code>ggplot2</code> must include the following:</p> <ul> <li>Data</li> <li>Aesthetic mapping (aes)<ul> <li>Describes how variables are mapped onto graphical attributes</li> <li>Visual attribute of data including x-y axes, color, fill, shape, and alpha</li> </ul> </li> <li>Geometric objects (geom)<ul> <li>Determines how values are rendered graphically, as bars (geom_bar), scatterplot (geom_point), line (geom_line), etc.</li> </ul> </li> </ul> <p>Thus, the template for graphic in  <code>ggplot2</code> is: <pre><code>&lt;DATA&gt; %&gt;%\n    ggplot(aes(&lt;MAPPINGS&gt;)) +\n    &lt;GEOM_FUNCTION&gt;()\n</code></pre></p> <p>Using this template, let's make a ggplot plotting the relationship between runtime and year of release.  <pre><code>unmessy_movies %&gt;%\n  ggplot(aes(x=year, y=runtime))+geom_point()\n</code></pre> This should produce a plot similar to this one, in the bottom right pane of your RStudio window. </p>"},{"location":"visualizing/#customizing-plots","title":"Customizing plots","text":"<p><code>ggplot2</code> offers a variety of options for customization. You can add customize the transparency of the points in your plots by using a <code>alpha</code> argument in your <code>geom_point()</code> function. You can use <code>geom_jitter()</code> to include jitter in your plots. </p> <p>You can also use a <code>color</code> arugment inside the geom_function to customize the colour of your data points. For this, you can use either a set colour, or assign colours based on another variable. Let's give this a try with a smaller dataset, the movies_first100 data frame. <pre><code>colourful_plot &lt;- movies_first100 %&gt;% \n  ggplot(aes(x=year, y=runtime)) + geom_jitter(aes(color=primary_genre), alpha=0.5)\n</code></pre></p> <p>Feel free to play around with the colours, transparency, jitter, and style. For more on the customization options, check out the ggplot2 documentation and the ggplot2 cheatsheet.</p> <p>As you see above, we can also assign plots to objects. We don't need to do this to see them, but it can be useful for keeping track of our graphics, and for saving them. Use the following code to save your plot. </p> <pre><code>ggsave(\"./fig_output/colourful_jitterplot.png\", plot=colourful_plot)\n</code></pre> <p>Note</p> <p>You do not need to include the <code>plot</code> argument in your <code>ggsave()</code> function. If you leave it blank, it will simply save the most recent plot. </p> <p>There are also options for plotting more categorical data. The type of plot being produced is dtermined by the geom function - the second piece of the ggplot formula. In addition to <code>geom_point</code> and <code>geom_jitter</code>, which we have already seen, you can also use <code>geom_boxplot</code> to make box plots, or <code>geom_bar</code> to make barplots. </p> <p>Let's try making a boxplot to visualize the differences in average ratings across genres. Boxplots can also have customized colours. Try running the following: <pre><code>unmessy_movies %&gt;%\n  ggplot(aes(x = primary_genre, y = ave_rating)) +\n  geom_boxplot(aes(fill=primary_genre))\n</code></pre></p> <p>We can also add custom titles to our plots using different arguments within a <code>labs()</code> function, including a <code>title</code>, <code>subtitle</code> and <code>caption</code>. The <code>labs()</code> function is added to the end of the ggplot formula with a <code>+</code>.</p> <p>Practice. Let's modify our boxplot to make it more readable and prettier! Update the code above to include the title \"Average movie rating by genre,' and to include the primary genre variable as the fill. Finally, add the following to the end of your codeblock to clean up the genre labels on the x-axis: <code>theme(axis.text.x = element_blank())</code>. Be sure to save your plot afterwards. </p> Solution <pre><code>unmessy_movies %&gt;%\n    ggplot(aes(x = primary_genre, y = ave_rating)) +\n    geom_boxplot(aes(fill=primary_genre)) +\n    labs(title=\"Average movie rating by genre\") +\n    theme(axis.text.x = element_blank())\n\nggsave(\"./fig_output/colourful_boxplot.png\")\n</code></pre> <p>You should end up with a plot similar to this one: </p>"},{"location":"old%20pages/data_types/","title":"Data Types","text":"<p>The most common data types in R are:</p> <ol> <li>Numeric data (numbers with decimal points, either integers or floats)</li> <li>Character data (text strings)</li> <li>Factor data (categorial data with a fixed set of values or levels)</li> <li>Logical data (boolean values or logical values)</li> </ol> <p>Data types are important because they determine how data is stored, processed, and analyzed. Choosing the appropriate data type can help you optimize your memory usage, perform the necessary data manipulations, conduct the appropriate statistical analyses, and create effective visualizations of your data.</p> <p>Data can be contained within a number of structures, including vectors, matrices, lists, factors, arrays, and data frames.</p>"},{"location":"old%20pages/data_types/#vectors","title":"Vectors","text":"<p>A vector is a basic data structure that represents a sequence of values of the same data type, whether numbers or letters. </p> <p>Creating vectors is straightforward: you just use the assignment operator and the c() function, which combines values. Try running the following code to make some vectors describing the Hollywood Chris's: <pre><code>chris_vector &lt;- c('pratt','hemsworth')\nchris_age_vector &lt;- c(44,46,42,45)\n</code></pre> Now that you've created these two vectors, you should see them in your environment in the top right pane of the RStudio console.</p> <p>Note</p> <p>Be sure to include quotation marks around the text data you're combining into a vector. If you do not have them, R will assume that you are referring to objects, not data values.</p> <p>You can call functions on vectors. For example, you can inspect the length, structure, and type of vectors. Run these three functions. Your output will appear in the console. <pre><code>length(chris_age_vector)\nstr(chris_age_vector)\ntypeof(chris_vector)\n</code></pre></p> Output <pre><code>&gt; length(chris_age_vector)\n[1] 4\n&gt; str(chris_age_vector)\n num [1:4] 44 46 42 45\n&gt; typeof(chris_vector)\n[1] \"character\"\n</code></pre> <p>It is also fairly straightforward to add elements to the beggining or end of your vector. Run the following code in your source editor or console. <pre><code>chris_vector &lt;-c(chris_vector, \"pine\")\nchris_vector &lt;-c(\"evans\",chris_vector)\n</code></pre> Once you've done this, you should see the values of chris_vector change in the environment pane.</p> <p>Importantly, if you try to put data of different types into one vector, R will coerce them automatically to all be the same type.</p> <p>Let's try creating a vector including the last name and age for two of the Hollywood Chris's. Basically, we are trying to make a vector with two strings and two integers. <pre><code>name_age_vector &lt;- c(\"evans\", 44, \"pratt\", 46)\n</code></pre> What happens to the data in our vector? Call <code>str(name_age_vector)</code>. How has R changed it? </p> Solution <p>R will have coerced the vector into a character vector. This means that all four values, the ages included, will be treated as text. </p> <p>When different data types are combined within a single atomic vector, R applies a coercion hierarchy to determine the resulting data type of the entire vector. Data are coerced from simplest to richest, followng the order of Logical -&gt; Integer -&gt; Numeric -&gt; Complex -&gt; Character. </p> <p>For example: If a vector contains both logical and integer values, all logical values will be coerced to integer (e.g., TRUE becomes 1, FALSE becomes 0). Or, if a vector contains numeric and character values, all numeric values will be coerced to character (as happened in our example).</p>"},{"location":"old%20pages/data_types/#data-frames","title":"Data frames","text":"<p>Data frames are another very common type of data structure used in R. A data frame is a two-dimensional tabular structure representing a grid of data, where each row represents an observation and each column represents a variable. </p> <p>R comes with a number of built-in data frames that you can use. For example, we can call the built-in data frame iris, which contains measurements of the length and width of petals and sepals for three species of iris flowers (setosa, versicolor, and virginica).</p> <p>To do this, use the following function: <pre><code>data(iris)\n</code></pre> The data frame should appear in your environment. You will also see a preview of the data appear in the console. </p> A summary of your iris data will appear in the Environment. <p>If you want to get a closer look at your data, you can either double click it in the environment pain, or run the command <code>view(iris)</code>. You can also import foreign data (data from outside of R) into RStudio. We'll cover how to do that later on in this workshop. </p>"},{"location":"old%20pages/functions/","title":"Functions","text":"<p>A function is a 'canned script' that automates a block of code that performs a specifc task and can be easily called and executed by the user. Functions are an essential component of programming in R. </p> <p>When R is installed, it comes with the default package <code>base</code> which contains a number of built-in functions. These include:</p> <ul> <li><code>mean()</code> calculates the mean of a vector of numbers</li> <li><code>sd()</code> calculates the standard deviation of a vector of numbers</li> <li><code>str()</code> displays the structure of an R object</li> <li><code>table()</code> creates a frequency table of a vector or factor</li> <li><code>plot()</code> creates a basic plot of data</li> </ul> <p>Try calculating the average age of the Hollywood Chris's using some of R's built-in functions. What function will you use? What output do you get? </p> Output <pre><code>&gt; mean(chris_age_vector)\n[1] 44.25\n</code></pre>"},{"location":"old%20pages/functions/#packages","title":"Packages","text":"<p>Different packages in R will come with their own built-in functions. Packages are collections of data, functions, and documentation. Packages are how we expand R beyond the base package. </p> <p>R packages are developed by the user community, and are all available for free. The Packages tab in RStudio lists all packages already installed in your R instance. </p> All already installed packages are listed under the Packages tab. <p>For a full list of all published packages, you can check out the R website.</p> <p>Packages only need to be installed once. Once they're installed, though, you do need to call them before you can use them and their built-in functions. Let's practice installing and calling packages with <code>tidyverse</code>, a very common R package for simple data work.  <pre><code>#installing a package\ninstall.packages('tidyverse')\n\n##calling a package\nlibrary(tidyverse)\n</code></pre> Now you should see <code>tidyverse</code> appear in the Packages tab. </p> <p>Alternatively, you can install a package by clicking the Install button on the top left of the Packages pane. Similarly, you can load a package by checking the box beside the installed package. In both cases, you will see the work that R is doing to install and load the package in the Console. </p>"},{"location":"old%20pages/operators/","title":"Operators","text":"<p>Operators are special symbols or keywords used to perform operations on one or more values. Common operators include:</p> <ul> <li>Assignment operators. We can use the operators <code>&lt;-</code> and <code>=</code> to assign a value to a variable/object. When naming an object in R, avoid using the names of fundamental objects (like 'mean), periods, or numbers at the beginning. Try creating variables for the day and month and assigning them values by running the following in the Source Editor:  <pre><code>day &lt;- 3\nmonth = 10\n</code></pre></li> </ul> <p>Note</p> <p>RStudio allows for several quick keyboard shortcuts. One is to press Alt+- (on PC) or Option+- (on mac) to write <code>&lt;-</code></p> <ul> <li>Arithmetic operators. The operators <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> are used for basic mathematical calculations, namely addition, subtraction, multiplication, and division. Try running the following in your Source Editor and watching what appears in the console: <pre><code>4+2\n4-2\n4*2\n4/2\n</code></pre></li> </ul> Output <pre><code>&gt; 4+2\n[1] 6\n&gt; 4-2\n[1] 2\n&gt; 4*2\n[1] 8\n&gt; 4/2\n[1] 2\n</code></pre> <ul> <li>Comparison operators. The operators <code>&lt;</code>, <code>&gt;</code>, and <code>==</code> return a logical values when used to compare two things. Try running the following: <pre><code>4==3\n4!=3\n4&gt;3\n4&lt;3\n</code></pre></li> </ul> Output <pre><code>&gt; 4==3\n[1] FALSE\n&gt; 4!=3\n[1] TRUE\n&gt; 4&gt;3\n[1] TRUE\n&gt; 4&lt;3\n[1] FALSE\n</code></pre> <ul> <li>Logical operators. The operators <code>&amp;</code> (and), <code>|</code> (or), and <code>!</code> (not) are used to perform logical operators. These are a bit more complicated to use, but here is a simple example: <pre><code>#the single &amp; operator represents an element-wise logical AND. It will return TRUE if both corresponding elements are true. Run the following:\nc(TRUE,TRUE,FALSE) &amp; c(TRUE,FALSE,FALSE)\n\n#Running the code above should return the following output:\n[1]  TRUE FALSE FALSE\n</code></pre></li> <li>Other miscellaneous operators:<ul> <li>The hash sign <code>#</code> indicates a comment in the code</li> <li>The colon sign <code>:</code> creates a sequence of numbers </li> <li>The square brackets <code>[]</code> indexed an object, such as a vector</li> <li>The dollar sign <code>$</code> accesses a variable from a dataframe</li> <li>The percent sign <code>%</code> is used for some special operators to string operations together</li> <li>The double colon <code>::</code> accesses functions or variables from a specific package</li> </ul> </li> </ul>"},{"location":"old%20pages/starting/","title":"Getting Started","text":"<p>We're now going to put some of these functions and operations into practice, and use them to explore our dataset of movies. </p>"},{"location":"old%20pages/starting/#creating-a-project","title":"Creating a project","text":"<p>Start by creating a new project. To do this, navigate to File and select New Project. From there, you will be given the option to create a project from a new or existing directory. Select New Directory and then New Project. </p> <p>You will then be able to give your new project a directory name; I'm going to name mine unmessy_movies. You also have the option of creating the project as a subdirectory of another directory. I am going to create my project as a subdirectory of <code>~/Documents/R</code> (a folder I created to store my R work), but you can put yours where you like, or even leave it blank.</p> You can determine the name and location of your new project"},{"location":"old%20pages/starting/#setting-a-working-directory","title":"Setting a working directory","text":"<p>It is always a good idea to set up an organized working directory. The working directory refers to the location on your computer where R will be reading and writing files. </p> <p>We're going to set up a fairly simple organization scheme, with separate file folders for:</p> <ul> <li><code>data/</code> to store your raw data and intermediate datasets. For the sake of transparency and provenance, you should always keep a copy of your raw data accessible and do as much of your data cleanup and preprocessing programmatically (i.e., with scripts, rather than manually) as possible,</li> <li><code>data_output/</code> to store modified data separtely from the original datasets,</li> <li><code>fig_output/</code> to store any graphics we generate, and</li> <li><code>scripts/</code> to store our R scripts.</li> </ul> <p>To create these four folders, run the following code:</p> <pre><code>dir.create('data')\ndir.create('data_output')\ndir.create('fig_output')\ndir.create('scripts')\n</code></pre> <p>Note</p> <p>You can check your working directory by running the command <code>getwd()</code>. If you are not where you'd like to be working, you can set your working directory by running the command <code>setwd('my/path')</code> where 'my/path' is the filepath to your desired directory. Try running <code>getwd()</code>. Is the output what you expected?</p>"},{"location":"old%20pages/starting/#importing-data","title":"Importing data","text":"<p>Now that we have our working directory set up, we can import our unmessy_movies.csv data. </p> <p>There are two ways to import data. The simplest way is to navigate to the Import Dataset dropdown menu in the toolbar of the Environment tab. From there, select the appropriate source (in this case, From Text(base)...). That will open a pop up window where you can navigate to, and select, your data. </p> <p>Alternatively, you can run code to import the data. Run the code below, after updating the filepath with one that locates the data on your computer. <pre><code>#I use a macbook, so to run this on PC you will need to update the filepath to begin with a \"C:\" \n\nunmessy_movies &lt;- read.csv(\"~/Downloads/unmessy_movies/data/unmessy_movies.csv\")\n</code></pre> Now that our data is loaded in R, we will want to save it. To do so, run the following line of code:  <pre><code>write.csv(unmessy_movies,\"./data/original_unmessy_movies.csv\")\n</code></pre></p>"}]}